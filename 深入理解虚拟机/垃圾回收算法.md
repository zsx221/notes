     垃圾回收算法
        标记-清除算法(Mark-Sweep)
           这是最基础的收集算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：
           首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
           之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。
           它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，
            当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
           
        复制算法(Copying)
        
            为了解决效率问题，一种称为“复制”(Copying)的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，
            然后再把已使用过的内存空间一次清理掉。
            这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。
            只是这种算法的代价是将内存缩小为原来的一半，未免太高了一点。
            但是这种算法的效率相当高，所以，现在的商业虚拟机都采用这种收集算法来回收新生代。为什么新生代可以使用复制算法呢？
            IBM 有专门研究表明，新生代中的对象 98% 都是朝生夕死，所以就不需要按照1:1的比例来划分内存空间。这里鉴于此，新生代采用了如下的划分策略。
            现在把新生代再划分为三部分，一块较大的 Eden(伊甸园) 和两块较小的 Survivor(幸存者) 区域。
            当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。HotSpot
            虚拟机默认Eden和Survivor的大小比例是8∶1，也就是每次新生代中可用内存空间为整个新生代容量的90%(80%+10%)，只有10%的内存是会被“浪费”的。
            这样清理完成后，原来的 Survivor 就空了，并一直保持为空，直到下次 Minor GC 时，它再作为存活对象的盛放地。两个 Survivor 就这样轮流当做 GC 过程中新生代存活对象的中转站。
            但是，如果使用复制算法的内存区域有大量的存活对象时，复制算法就会变得捉襟见肘，这时需要更大的 Survivor 区用于盛放那些存活对象，甚至可能需要 1:1的比例。所以针对堆内存区域的老年代，
            就有了下面的算法。
        
        标记-整理算法
            标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。
            这种方法避免了碎片的产生，同时也不需要一块额外的内存空间，对于老年代会比较合适。
            但是相比复制算法，虽然该算法占用的内存空间少，但是耗费的垃圾回收时间会比复制算法久，所以上面也说了
            我们应该尽量避免或者减少 Full GC 的发生。
            这两种算法用精炼的语言描述就是
                复制算法:用空间换时间
                标记-整理算法：用时间换空间
