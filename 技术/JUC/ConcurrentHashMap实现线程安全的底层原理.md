    JDK 1.8 以前，多个数组，分段加锁，一个数组一个锁4
    JDK 1.8 以后，优化细粒度，一个数组，每个元素进行 CAS，如果失败说明有人了，此时synchronized 对数组元素加锁、
        链表+红黑树处理，对数组每个元素加锁
    多个线程要访问同一个数据，synchronized 加锁，CAS 去进行安全的累加，去实现多线程场景下的安全的更新一个数据的效果
        比较多的一个场景下，可能就是多个线程同时读写一个HashMap

    一个大的数组，数组里每个元素进行 put 操作，都是有一个不同的锁，刚开始进行 put的时候
     如果两个线程都是在数组[5]这个位置进行 put,这个时候，对数组[5]这个位置进行 put的时候，采取的是 CAS 的策略

    同一个时间，只有一个线程能成功执行这个 CAS，就是说他刚开始先获取一下数组[5]这个位置的值，nul，然后执行 CAS，线程1
        比较一下，put 进去我的这条数据，同时间，其他的线程执行 CAS，都会失败

    分段加锁，通过对数组每个元素执行 CAS 的策略，如果是很多线程对数组里不同的元素执行 put，大家是没有关系的
        如果其他人失败了，其他人此时会发现说，数组[5]以及放入了元素。
    就需要在这个位置基于链表+红黑树来进行处理，synchronized(数组[5])，加锁，基于链表或者是红黑树在这个位置插进去自己的数据