    java内存模型

    连环炮:内存模型-→原子性、可见性、有序性 ->volatile+可见性->volatile+有序性
        （指令重排+ happens-before)->voaltile+原子性->volatile底层的原理（内存屏障级别的原理)
    所以针对这些连环炮来提出几个疑问，并且做出回答

    1、探讨一下对java内存模型的理解
        答：是Java 定义的并发编程相关的一组规范，除了抽象了线程和主内存之间的关系之外，
            其还规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，
             其主要目的是为了简化多线程编程，增强程序可移植性的。

    2、原子性、可见性、有序性
        答：原子性：一个操作或一些操作要么全部执行，要么都不执行
            可见性：多个线程访问一个变量并且修改值的时候，其他线程是能立刻看到修改后的值
            有序性：程序执行按照代码的先后顺序执行，通常，编译器和指令器为了提高性能，会对指令进行指令重排，
              不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的，
                这对单线程是没有影响的，但是会影响多线程的结果。

    3、volatile+可见性，volatile怎么保证可见性？
        答： lock指令: volatile保证可见性
         对volatile修饰的变量，执行写操作的话，JVM会发送一条lock前缀指令给CPU，CPU在计算完之后会立即将这个值写回主内存
          同时因为有MESI缓存一致性协议，所以各个CPU都会对总线进行嗅探，自己本地缓存中的数据是否被别人修改
           如果发现别人修改了某个缓存的数据，那么CPU就会将自己本地缓存的数据过期掉
             然后 这个CPU上执行的线程在读取那个变量的时候，就会从主内存重新加载最新的数据了
         基于lock前缀指令＋+MESI缓存一致性协议来保证可见性。ESI协议是一个基于失效的缓存一致性协议,是支持写回(write-back)缓存的最常用协议

    4、volatile+有序性：volatile怎么保证有序性？
        答：volatile修饰的值中，在每个volatile写操作前面，加StoreStore屏障，禁止普通写与之重排。在volatile后面加StoreLoad屏障，
            禁止下面的volatile读/写重排。
         每个volatile读操作后面,加LoadLoad屏障,禁止下面的普通读和voaltile读重排;
         每个volatile读操作后面，加LoadStore屏障，禁止下面的普通写和 volatile读重排;
    5、了解指令重排和happens-before吗？
        答：指令编排，是指编译器和指令器为了提高性能，对指令进行重新排序，在不影响原代码的最终结果的前提下。
            而happens-before是规定了一些规范，在一些情况下不允许指令重排。
    6、volatile怎么保证原子性呢？或者volatile可以保证原子性吗？
        不行。volatile不能保证原子性，除非某些极端情况下保证原子性的效果。
        Oracle中对64位的long的数字进行操作，volatile可以保证原子性。(即指令的6种操作)
        只能加锁。
    7、volatile底层原理是什么呢？内存屏障级别的原理？
            
    1、JMM(Java Memory Model)
        定义了线程和主内存之间的抽象关系，即JMM定义了JVM在计算机内存(RAM)中的工作方式。
        JMM 是共享内存的并发模型，线程之间主要通过读-写共享变量(堆内存中的实例域，静态域和数组元素)来完成隐式通信。
        JMM 控制 Java 线程之间的通信，决定一个线程对共享变量的写入何时对另一个线程可见。                                                        
        理解JMM就是理解read、load、use、assign、store、write这几个命令。

    2、在了解happens-before之前，得先了解指令重排的概念
        2.1什么是重排序？
            为了提高性能，在遵守 as-if-serial 语义（即不管怎么重排序，单线程下程序的执行结果不能被改变。编译器，runtime 和处理器都必须遵守）
                的情况下，编译器和处理器常常会对指令做重排序。
        2.2指令重排分为几种类型？
            2.2.1编译器优化重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
            2.2.2指令级并行重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
            2.2.3内存系统重排序。由于处理器使用缓存和读 / 写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。
        例子：
                `int a = 0;
                                // 线程 A
                a = 1;              // 1
                flag = true;        // 2
                                // 线程 B
                if (flag) {         // 3
                int i = a;          // 4
                }`
                单看上面的程序好像没有问题，最后 i 的值是 1。但是为了提高性能，编译器和处理器常常会在不改变数据依赖的情况下对指令做重排序。
                假设线程 A 在执行时被重排序成先执行代码 2，再执行代码 1；
                而线程 B 在线程 A 执行完代码 2 后，读取了 flag 变量。由于条件判断为真，线程 B 将读取变量 a。
                此时，变量 a 还根本没有被线程 A 写入，那么 i 最后的值是 0，导致执行结果不正确。
                这里仍然可以使用 volatile 关键字进行禁止指令重排。

    3、happens-before(在特定情况下，不允许编译器、指令器对你的代码进行指令重排，保证代码的有序性和可见性)
        如果一个操作执行的结果需要对另一个操作可见这里的“可见”是指当一条线程修改了某个变量的值，
            新值对于其他线程来说是可以立即得知的，那么这两个操作之间必须存在 happens-before 关系。
                这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。
            一、什么是happens-before？
                happens-before：A happens-before B就是A先行发生于B（这种说法不是很准确），定义为hb(A, B)。
                    在Java内存模型中，happens-before的意思是前一个操作的结果可以被后续操作获取。
            二、为什么需要happens-before？
                JVM会对代码进行编译优化，会出现指令重排序情况，为了避免编译优化对并发编程安全性的影响，
                    需要happens-before规则定义一些禁止编译优化的场景，保证并发编程的正确性。
            三、有哪些happens-before规则？
                1、程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。
                2、监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。先lock，后unlock
                3、volatile变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。
                4、传递性：如果甲 happens- before 乙，且乙 happens- before 丙，那么甲 happens- before 丙。
                5、线程启动规则:Thread对象的start()方法先行发生于此线程的每个一个动作, thread.start()，thread.interrupt().
                6、线程中断规则:对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
                7、线程终结规则:线程中所有的操作都先行发生于线程的终止检测，我们可以通过
                    Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
                8、对象终结规则:一个对象的初始化完成先行发生于他的finalize()方法的开始

    4、volatile与happens-before关系
        访问volatile变量在语句间建立了happens-before关系。
        当写入一个volatile变量时，它与之后的该变量的读操作建立了happens-before关系。
        那么什么是happens-before关系呢？简单来说，就是保证一个语句的影响会被另一个语句看到。