    Redis的高并发和快速原因
        1.redis是基于内存的，内存的读写速度非常快；
        
        2.redis是单线程的，省去了很多上下文切换线程的时间；
        
        3.redis使用多路复用技术，可以处理并发的连接。非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。
            epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间。
        Redis采用了IO多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。
        多路复用：多路指的是多个socket网络连接，复用指的是一个线程。
     Redis在持久化时fork出一个子进程，这时已经有两个进程了，怎么能说是单线程呢？
        Redis是单线程的，主要是指Redis的网络IO和键值对读写是由一个线程来完成的。而Redis的其他功能，如持久化、异步删除、集群数据同步等
            则是依赖其他线程来执行的。所以，说Redis是单线程的只是一种习惯的说法，事实上它的底层不是单线程的。

        set和zset有什么区别？
            一个无序一个有序
        说一下Redis中的watch命令
            很多时候，要确保事务中的数据没有被其他客户端修改才执行该事务。Redis提供了watch命令来解决这类问题，这是一种乐观锁的机制。
                客户端通过watch命令，要求服务器对一个或多个key进行监视，如果在客户端执行事务之前，这些key发生了变化，则服务器将拒绝执行客户端提交的事务，并向它返回一个空值。
            

    
    为什么Redis是单线程的?
        优势：
            因为redis是基于内存的操作，cpu不是redis的瓶颈，redis的瓶颈只会是机器的内存大小和网络带宽，既然单线程容易，而且cpu
                不会成为瓶颈，那就顺理成章采用单线程的方案。
            在单线程的情况下，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。
            采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU。
            Redis全程使用hash结构，读取速度快
        劣势：
            无法发挥多核CPU性能，不过可以通过在单机开多个Redis实例来完善。