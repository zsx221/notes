1、为何要使用分布式锁？用本地锁就能解决大部分问题，那分布式锁的实际作用式什么呢？
答：本地锁的缺点：锁不住分布式的访问，在分布式的系统中，有几个服务，就有几把本地锁，为了保证一个方法在高并发情况下的同一时间只能被同一个线程执行，这个时候，我们就用分布锁。


2、如何使用分布式锁呢？
    2.1  使用redis中自带的setnx操作来实现分布式锁。
      具体操作：在缓存中访问不到数据，这个时候，我们利用setnx来设置一个lock固定值，等到业务结束之后释放锁，这样，每次访问进来，先判断这把锁是否存在，如果存在，就等待，不存在就抢占。
      问题：如果这个服务的业务在释放锁之前就崩了，那么，这个把锁就不能被释放
      解决：保证加锁的原子性操作。（这个原子性指的是：这个锁没被释放之前，其他的线程不能进行加锁，并且在业务崩了的情况下，也能保证说，锁也能自动释放）
    2.2  使用redis中自带的setnx  ex px来实现锁的过期时间。
      具体操作：加锁的时候使用过期时间，来保证即使业务崩了，也不会影响其他客户端的访问。
      问题：如果锁的过期时间设置为3秒，业务的执行时间是7秒，那么业务还没有执行完成的时候，锁就被释放掉了。
      这样会出现问题：它把别人加的锁给释放了...
      解决：保证每次删锁的时候，删的是自己当前的那把锁。
     2.3 使用uuid作为lock的value
      具体操作：加锁的时候，使用uuid作为lock的value，在释放锁的时候判断，当前的lock值，是否是lock的value，如果是就释放锁，这样就不会误删掉其他访问的锁。
      问题：如果在判断uuid是否等于lock的value值的时候，出现了延迟，在判断时，uuid==lock.value，但是由于延迟，2秒之后这个值才能传回业务的判断，但是1秒内这个value就过期了
      这个时候，业务进行正常的释放锁，但是释放的是下一个访问的锁，就出现了问题。
      解决：保证释放锁的原子性(确保释放的是自己的锁，即锁的原子性操作)
     2.4 使用lua的脚本解锁
        具体操作：
                //lua脚本解锁
                //key就是lock的集合,KEYS[1]代表者当前的lock值，ARGV就代表者uuid的集合，那么ARGV[1]代表者当前uuid的值
                String script = "if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end";
                // 删除锁
                Long lock1 = redisTemplate.execute(new DefaultRedisScript<Long>(script, Long.class), Arrays.asList("lock"), uuid);
                
         为什么使用lua的脚本解锁能保证原子性？
         答：Redis使用同一个Lua解释器来执行所有命令，同时，Redis保证以一种原子性的方式来执行脚本：当lua脚本在执行的时候，
         不会有其他脚本和命令同时执行，这种语义类似于 MULTI/EXEC。从别的客户端的视角来看，一个lua脚本要么不可见，要么已经执行完。
