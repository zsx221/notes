大家看到事务，可能会很多个疑问，那如下是我的几个疑问：
  1、事务是什么？
    答：事务是一个严密的逻辑操作，它规定了所有的操作必须全部成功完成，要么进行回滚。简单来说就是：同患难，共甘苦。
  2、事务解决了什么问题？
    答：
      事务解决什么问题，取决它的四个特性，acid，原子性、一致性、隔离性、持久性，
      原子性：一个事务必须是一个原子操作、同时成功或者同时失败。
      一致性：事务的执行前后的完整性保持一致，就拿转账来说，a有100块，b有100块，a向b转账50，如果转账成功，那么a应该是50，b应该是150块。
      隔离性：事务之间是透明的，一个事务是不能干扰另外一个事务，select会通过mvcc实现(undo log和readview)，增删改会加锁(写锁)。
      持久性：一旦事务提交，就会持久化到数据库里面。
      其中，由于事务的隔离级别，造成了几个问题，脏读(读到了别人未提交的事务数据)、不可重复读(在一个事务读取的数据不一致问题)
      幻读(一个事务读取到了其他事务因为插入数据导致的不一致问题)
      脏写：一个事务修改了其他事务未提交的数据，其他事务回滚了，此时由于undo log日志中存放的是一开始的数据记录，
      那么其他事务回滚就会把这条数据回滚为最初的数据值，导致这个事务的修改无效
      丢失更新：一个事务修改了其他事务未提交的数据，其他事务提交了,而事务之间并不知道，发生更新丢失。
  3、事务是怎么解决的呢？
      隔离级别读写数据的时候是有对应的锁机制实现的。所以不会出现写一致性问题。

      确切的说修改数据用到了排他锁保证修改时事务串行化，一个事务没法修改其他事务未提交的数据,
        所以你在mysql中开启两个事务同时操作一行记录的话其中一个事务的sql一定是阻塞的状态，不信可以试试。

      Read Uncommitted(RU未提交读)：事务未提交的数据对其他事务也是可见的,会出现脏读，
        未解决读一致性问题,读数据时未增加锁，在修改数据时增加行级写排它锁。

      Read Committed(RC已提交读)：一个事务开始之后,只能看到已提交的事务所做的修改.会出现不可重复读,解决了脏读。
        读取数据时增加行级共享锁，读取结束，立即释放，在修改数据时增加行级排它锁，直到事务结束才释放

      Repeatable Read(RR可重复读，Mysq默认级别)：在同一个事务中不会读取到其他事务提交的数据。可能出现幻读，
        但在mysql的innodb中RR实现基于ReadView机制同时避免了不可重复读和幻读。在数据读取时，增加行级共享锁，直到事务结束,在修改数据过程中，
          必须增加行级排它锁，直到事务结束才释放。

      Serializable(S串行化)：解决所有问题，强制事务的串行执行，通过隐式加共享锁实现即sql后追加lock in share mode,
        会和update、delete互斥。读取数据时，必须先增加表级共享锁，直到事务结束时才释放，修改数据时，必须先增加表级排它锁，直到事务结束才释放；
