    ReadView机制已经学过了，那现在有几个疑问。
    1、ReadView机制如何解决脏读呢？
        答：在回答这个之前呢，首先问自己一个问题，脏读是什么意思呢？就是在一个事务未提交修改的数据，被另外一个事务
            读到了，造成了脏读。回答了这个问题，咱们继续回答，ReadView机制如何去解决脏读呢？
            事务A，事务B并发执行，事务A的id为10，事务B的id为30。
            首先事务B查询t表中的sno为10，
            事务A对t表中的sno进行修改，update t set sno=20，并且更新undo log日志;
            此时如果innoDB的隔离级别为读提交，那么b再次查询，会产生一个ReadView视图，此时视图中的几个字段分别为：m_ids[10-30],min_trx_id=10
            max_trx_id=20,creator_trx_id=30;
            最新的数据更新事务id(row_trx_id)为10，在10-30之内，再继续判断是否存在m_ids数组之内，存在，则不可读，去读上一个版本的数据，读到了10.
    
    2、ReadView机制如何解决幻读呢？
        答：还是依旧来解答一下幻读的意思，就是你在事务提交之前对数据的查询条数可能会不一致，别人新插入的数据你也能看到。
            一个编辑人员更改作者提交的文档，但当生产部门将其更改内容合并到该文档的主复本时，发现作者已将未编辑的新材料添加到该文档中。
            如何解决呢？还是ReadView机制，只不过这个隔离级别必须在可重复读之上
                原因就是在读提交隔离级别下，在一个事务内，每次查询，都会重新创建一个新的 ReadView 视图
                而在可重复读的隔离级别下，在一个事务内，只有首次查询才会创建一个视图ReadView视图。
                这个同时解决了可重复读的问题。
    3、快照读和立即读
        答：为什么单独拿出来说呢，是幻读有一个特殊的地方，就是快照读和立即读。
            可重复读已经解决了幻读，是解决了幻读的快照读，那两者有什么区别呢？
                我们在实际的工作中，所使用的 SQL 查询语句基本都是快照读。
                我们都强制性的读取最新版本的数据，这种读称之为当前读，也就是读取最新的数据
                例如在 select 语句后面加上「for update 或者 lock in share mode」等。
    4、不可重复度、幻读、脏读的区别、和侧重点
        不可重复读的重点是修改 : 同一事务，两次读取到的数据不一样，取决于每次查询都会生成一个新的readview视图。
        
        幻读的重点在于新增或者删除:同样的条件, 第 1 次和第 2 次读出来的记录数不一样
        
        脏读： 该隔离级别因为可以读取到其他事务中未提交的数据，而未提交的数据可能会发生回滚，因此我们把该级别读取到的数据称之为脏数据。
        
    
