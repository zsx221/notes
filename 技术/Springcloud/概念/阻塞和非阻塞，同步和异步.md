  堵塞和非堵塞型的
如果应用层调用的是阻塞型I/O，那么在调用之后，应用层即刻被挂起，一直出于等待数据返回的状态
  直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。

如果应用层调用的是非阻塞I/O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据）
  应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。）

这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态
  被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。 
  
  
  同步和异步
 阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。
  对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，
  或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；
  如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。 
  
  而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。
  
  这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。
   由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。
   
   
   老马在洗衣服   
      买了一台洗衣机
       同步堵塞：这台洗衣机只会洗衣服，老马要盯着它洗衣服，洗完只后还要按甩干，还不能去干其他事情（堵塞），而且，还要等洗衣机洗完只后去关掉电闸。
       异步堵塞：这台洗衣机功能提升了，洗完衣服会自动关机，老马只需要等它洗完衣服，按甩干，就去干其他事情，等到洗衣机报警就行。
       同步非堵塞：这台洗衣机稍微好一点，洗衣服全自动，老马可以放手去干其他事情，但是呢，还是要时不时哎，过来看看，洗完了没
       异步非堵塞：这台洗衣机可以，功能完备，全自动洗衣服，而且洗完之后自动关机，老马全程去干其他事情，两不耽误。

