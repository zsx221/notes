第一部分:数组和链表以及散列表的优势和劣势
    1.数组的优势/劣势
        答：查询快，增删慢
    ⒉链表的优势/劣势
        答：查询慢，增删快
    3.有没有一种方式整合两种数据结构的优势?
        散列表
    4.散列表有什么特点?
        答：集齐了数组和链表的优势，使得散列表具有查询快、增删快的优势。
    5.什么是哈希?
        答：哈希指的是把任意长度的输入，通过Hash算法变成固定长度的输出。
            这个映射的规则就是对应的Hash算法，而原始数据映射后的二进制串就是哈希值。
第二部分，HashMap原理讲解:
    1.HashMap的继承体系是什么样的?
         答：最核心的就是实现了Map<K,V>接口，和继承了AbstractMap<K,V>抽象类
    2.Node数据结构分析?
        答：hash值，key，value，next指针
    3.底层存储结构介绍?
        答：1.7之前是链表加数组，1.8是链表加数组和红黑树
    4.put数据原理分析?
        答：
          （1）计算key的hashCode
          （2）将key的hashCode作为计算因子，通过哈希算法计算HashMap的数组下标index
          （3）如果index下标的数组元素为空，直接put(新增元素)，然后
          （4）如果index下标的数组元素不为空，调用key的equal方法，判断index位置的链表是否存在
          （5）如果找到链表中某个元素与key的equals方法相等，则使用value更新
          （6）如果未找到链表中某个元素与key的equals方法相等，则新增
    5.什么是Hash碰撞?
        答：当两个不同的key，经过hash算法的高位与低位的异或运算，再通过与cap-1的&运算的余数相等时，就等于两个不同的key找到了同一个数组下标，这个就叫Hash碰撞。
    6.什么是链化?
        答：链化也是解决hash碰撞的一种方法，通过链化使得两个key在数组的同一个下标下形成链表，
    7.jdk8为什么引入红黑树?
        答：当链化严重时候，这个时候的查找效率就变低了，变成O(n)级别了，这个时候引入红黑树可以提高查找效率。
    8.HashMap扩容原理?
        答：resize()方法用来进行扩容，创建一个更大的数组，把old数组里面的数据搬过去。(通常是两次幂的形式扩容),特殊情况，比如旧的cap*2大于最大的容量，就会设置为最大的容量。
            还有一种就是oldcap大于maxcap,这个时候阈值就设置为maxcap，扩容之后，1.8为节省重新计算hash值的时间newTab[e.hash & (newCap - 1)]，这个是计算
第三部分,手撕源码:
    1.HashMap核心属性分析(threshold, loadFactory, size, modCount)
    2.构造方法分析
    3.HashMap put方法分析=>putVal方法分析
    4.HashMap resize扩容方法分析(核心)
