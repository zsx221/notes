    26、为什么互联网公司的面试官会极为重视JVM的考察?
        答：因为在大型项目中，多半是高并发、高可用的，一旦发生多次fullGC甚至于oom，那么对系统的性能影响很大，所以需要了解这方面的知识，来排查问题。
    27、JVM中有哪几块内存区域? Java8之后对内存分代做了什么改进?
        答：虚拟机栈、方法栈、本地方法栈、堆、程序计数器、常量池、堆外内存。
            1.8之后的改进：
                1）java7以前的版本Hotspot的方法区位于永久代，并且永久代和堆是互相隔离的，但是他们使用的物理内存是连续的。
                2）java8中方法区位于元空间，同时元空间不再与堆连续，而是存在于本地内存。
    28、你知道JVM是如何运行起来的吗?如何创建对象以及何时触发垃圾回收?
        答：一般是通过java -jar包的命令运行，其中，包内是字节码，jvm会找到你的main函数，通过类加载机制加载你的类，如果有父类，就会加载
            父类，然后进行验证，验证你的字节码是否规范，然后准备过程，对你的局部变量进行分配空间，并且暂时入栈，解释，对你的引用变量
                jvm对你的局部变量符号变成直接引用，最后就是初始化，对你的局部变量进行逻辑赋值。
    29、说说你对JVM的垃圾回收算法以及垃圾回收器的理解?
        答：在jvm中，每次有请求过来，jvm都会给一个线程进行处理请求，根据请求，创建不同的对象，也就意味着，经过长时间的累加，
            jvm的内存会被挤得越来越慢，导致性能下降，甚至内存溢出，这个时候需要垃圾回收器来进行gc，而垃圾回收算法是对垃圾回收器进行
            更加高效率的回收。
    30、你们生产环境中是如何设置JVM的内存参数以及垃圾回收参数的?
        我们会根据核心业务来进行推算，先计算一次请求会创建多少对象，以及对象的大小，然后根据模拟1秒通常会有多少个请求，
        来给jvm多大的内存，确定好jvm的内存，我们会再确定好新生代和老年代的内存分配，一般来说是1：2，然后再确定新生代中伊甸区
        和幸存区的内存分配，一般是8：1：1
    31、JVM可能会发生哪几种OOM?如何排查和处理线上系统的OOM问题?
        答：OOM实际上是out of Memory，就是内存溢出
            1: 堆内存不足    原因：大对象分配没有连续空间，可能存在内存泄露导致在多次GC之后还是无法找到一块足够大的空间容纳此对象。
            2: 永久代/元空间 原因：溢出，
            3: 方法栈溢出    原因：线程开的太多了，可以自己设置降低线程的大小。
            4: 分配超大数组  原因：这种情况一般是由于不合理的数组分配请求导致的，在为数组分配内存之前，JVM 会执行一项检查。
                要分配的数组在该平台是否可以寻址(addressable)，如果不能寻址(addressable)就会抛出这个错误。
            5: swap区溢出 1、swap 分区大小分配不足； 2、其他进程消耗了所有的内存。
               解决方案：1、其它服务进程可以选择性的拆分出去 2、加大swap分区大小，或者加大机器内存大小
    32、你在实际项目中是否做过JVM GC 优化，怎么做的?
        答：
    33、聊聊VM类加载器体系?为什么要使用双亲委派?如何自定义类加载?