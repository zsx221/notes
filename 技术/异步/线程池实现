工作顺序:
1)、线程池创建,准备好core数量的核心线程,准备接受任务
1.1、core满了，就将再进来的任务放入阻塞队列中。空闲的core就会自己去阻塞队列获取任务执行1.2、阻塞队列满了，就直接开新线程执行，最大只能开到max指定的数量
1.3、max满了就用RejectedExecutionHandler拒绝任务
1.4、max都执行完成，有很多空闲.在指定的时间keepALiveTime以后，释放max-core这些线程
new LinkedBLockingDeque<>():默认是工nteger的最大值。内存不够
—个线程池core 7，max 20 , queue: 50，100并发进来怎么分配的;
7个会立即得到执行，50个会进入队列，再开13个进行执行。剩下的30个就使用拒绝策略。
ThreadPoolExecutor executor = new ThreadPoolExecutor( corePoolSize: 5,
maximumPoolSize: 200,
keepAliveTime: 10,
TimeUnit.SECONDS,
new LinkedBlockingDeque<>(capacity: 100006),Executors.defaultThreadFactory(),
new ThreadPoolExecutor.AbortPolicy());
Executors.newCachedThreadPooL( ) core是0，所有都可回收。
Executors.newFixedThreadPool(）固定大小,core=max;都不可回收Executors.newScheduledThreadPool()适合在定时任务的线程池。
Executors.newSingleThreadExecutor()单线程的线程池，后台从队列里面获取任务，挨个执行
